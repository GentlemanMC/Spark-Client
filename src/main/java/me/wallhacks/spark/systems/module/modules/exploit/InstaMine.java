package me.wallhacks.spark.systems.module.modules.exploit;

import me.wallhacks.spark.Spark;
import me.wallhacks.spark.event.player.PacketSendEvent;
import me.wallhacks.spark.event.player.PlayerDamageBlockEvent;
import me.wallhacks.spark.event.player.PlayerLivingTickEvent;
import me.wallhacks.spark.systems.module.Module;
import me.wallhacks.spark.systems.setting.settings.BooleanSetting;
import me.wallhacks.spark.systems.setting.settings.IntSetting;
import me.wallhacks.spark.systems.setting.settings.ModeSetting;
import me.wallhacks.spark.util.MC;
import me.wallhacks.spark.util.player.itemswitcher.ItemSwitcher;
import me.wallhacks.spark.util.player.itemswitcher.itemswitchers.ItemForMineSwitchItem;
import me.wallhacks.spark.util.render.EspUtil;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.init.Blocks;
import net.minecraft.init.Items;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraftforge.client.event.RenderWorldLastEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

import java.awt.*;
import java.util.Arrays;

@Module.Registration(name = "InstaMine", description = "Packet mine but good!",alwaysListening = true)
public class InstaMine extends Module implements MC {

	public static InstaMine instance;
	public InstaMine() {
		instance = this;

	}

	IntSetting delay = new IntSetting("Delay", this, 0, 0, 10, "General");
	BooleanSetting swing = new BooleanSetting("Swing", this, false, "General");




	BooleanSetting ifBlock = new BooleanSetting("PauseIfEmpty", this, true, "Packets");
	BooleanSetting onPick = new BooleanSetting("OnlyPickaxe", this, false, "Packets");

	BooleanSetting instant = new BooleanSetting("Instant", this, false, "Packets");



	ModeSetting Switch = new ModeSetting("Switch", this, "Normal", Arrays.asList("Normal","Off","Silent"), "Packets");

	BooleanSetting instaSwitch = new BooleanSetting("SwitchForInstat", this, true,aBoolean -> !Switch.is("Off") && instant.isOn(), "Packets");




	boolean hasStarted = false;
	public BlockPos pos;
	EnumFacing facing;

	float progress = 0f;

	int pauseTimer = 0;




	@SubscribeEvent
	public void onBreak(PlayerDamageBlockEvent.Pre event){

		if(!isEnabled() && !Spark.breakManager.doInstaMine())
			return;

		if(onPick.isOn() && Items.DIAMOND_PICKAXE != mc.player.getHeldItemMainhand().getItem())
			return;


		if (!canBreak(event.getPos()))
			return;

		if(pos == null || !pos.equals(event.getPos())){
			progress = 0;
			hasStarted = false;
		}

		pos = event.getPos();
		facing = event.getFacing();
		hasSwitched = false;





		event.setReturnValue(false);
		event.setCanceled(true);
	}

	boolean hasSwitched = false;


	@SubscribeEvent
	public void onUpdate(PlayerLivingTickEvent event) {

		if(!isEnabled() && !Spark.breakManager.doInstaMine())
		{
			if(pos != null)
				pos = null;
			return;
		}

		if(pauseTimer > 0)
			pauseTimer--;
		else if(pos != null)
		{

			IBlockState b = mc.world.getBlockState(pos);

			if((b.getBlock() != Blocks.AIR || !ifBlock.isOn()))
			{
				if(hasStarted)
				{
					int lastSlot = mc.player.inventory.currentItem;

					if(!Switch.is("Off"))
						ItemSwitcher.Switch(new ItemForMineSwitchItem(b), ItemSwitcher.switchType.Mainhand);

					progress += b.getPlayerRelativeBlockHardness(this.mc.player, this.mc.player.world, pos);


					boolean sentStopDestroyPackets = false;

					if(swing.isOn())
						mc.player.swingArm(EnumHand.MAIN_HAND);




					if(!hasSwitched || lastSlot == mc.player.inventory.currentItem)
					{
						if(progress > 1f)
						{
							sentStopDestroyPackets = true;
							hasSwitched = true;
							mc.playerController.syncCurrentPlayItem();
							mc.player.connection.sendPacket(new CPacketPlayerDigging(
									CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, pos, facing
							));


							if(!instant.isOn())
								pos = null;

							pauseTimer = delay.getValue();
						}
					}

					if(progress >= 1.4f)
					{
						//fucked lol
						hasStarted = false;
					}

					if(Switch.is("Silent") || !sentStopDestroyPackets)
					{
						mc.player.inventory.currentItem = lastSlot;
						mc.playerController.syncCurrentPlayItem();
					}




				}
				else{
					mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, pos, facing));
					mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, pos, facing));
					hasStarted = true;
					progress = 0;
				}
			}
			else{
				if(instaSwitch.isOn())
					hasSwitched = false;
			}




		}

	}


	@SubscribeEvent
	public void onPacket(PacketSendEvent event) {


		if (event.getPacket() instanceof CPacketPlayerDigging)
		{
			CPacketPlayerDigging digging = event.getPacket();
			if(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK == digging.getAction())
			{
				if(pos != null)
					event.setCanceled(true);
			}
		}
	}

	@SubscribeEvent
	public void onRender(RenderWorldLastEvent event) {


		if(pos != null)
		{
			AxisAlignedBB B = mc.world.getBlockState(pos).getSelectedBoundingBox(mc.world, pos);

			EspUtil.boundingESPBox(new AxisAlignedBB(pos),new Color(157, 146, 146, 171), 2.0f);


		}

	}


	private boolean canBreak(BlockPos pos)
	{
		final IBlockState blockState = mc.world.getBlockState(pos);
		final Block block = blockState.getBlock();

		return block.getBlockHardness(blockState, mc.world, pos) != -1;
	}

}
