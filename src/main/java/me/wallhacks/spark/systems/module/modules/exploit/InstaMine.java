package me.wallhacks.spark.systems.module.modules.exploit;

import javafx.geometry.BoundingBox;
import me.wallhacks.spark.Spark;
import me.wallhacks.spark.event.player.PacketSendEvent;
import me.wallhacks.spark.event.player.PlayerDamageBlockEvent;
import me.wallhacks.spark.event.player.PlayerLivingTickEvent;
import me.wallhacks.spark.systems.module.Module;
import me.wallhacks.spark.systems.setting.settings.BooleanSetting;
import me.wallhacks.spark.systems.setting.settings.IntSetting;
import me.wallhacks.spark.systems.setting.settings.ModeSetting;
import me.wallhacks.spark.util.MC;
import me.wallhacks.spark.util.player.itemswitcher.ItemSwitcher;
import me.wallhacks.spark.util.player.itemswitcher.itemswitchers.ItemForMineSwitchItem;
import me.wallhacks.spark.util.render.EspUtil;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.init.Blocks;
import net.minecraft.init.Items;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraftforge.client.event.RenderWorldLastEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

import java.awt.*;
import java.util.Arrays;

@Module.Registration(name = "PacketMine", description = "Packet mine but good!",alwaysListening = true)
public class InstaMine extends Module implements MC {

	public static InstaMine instance;
	public InstaMine() {
		instance = this;

	}

	IntSetting delay = new IntSetting("Delay", this, 0, 0, 10);
	BooleanSetting instant = new BooleanSetting("Instant", this, false);
	ModeSetting Switch = new ModeSetting("Switch", this, "Normal", Arrays.asList("Normal","FastSwap","Off","Silent"));
	BooleanSetting instaSwitch = new BooleanSetting("SwitchForInstant", this, false,aBoolean -> (!Switch.is("Off") && instant.isOn()));




	public boolean hasStarted = false;
	public BlockPos pos;
	EnumFacing facing;

	int progress = 0;

	int pauseTimer = 0;




	@SubscribeEvent
	public void onBreak(PlayerDamageBlockEvent.Pre event){

		if(!isEnabled() && !Spark.breakManager.doInstaMine())
			return;
		if (!canBreak(event.getPos()))
			return;

		if(!event.getPos().equals(pos)){
			progress = 0;
			hasStarted = false;
			hasSwitched = false;
		}

		breakManager = Spark.breakManager.block != null;

		pos = event.getPos();
		facing = event.getFacing();

		event.setReturnValue(false);
		event.setCanceled(true);
	}

	public boolean hasSwitched = false;

	boolean breakManager = false;

	Block breaking;

	@SubscribeEvent
	public void onUpdate(PlayerLivingTickEvent event) {

		if(!isEnabled() && !Spark.breakManager.doInstaMine())
		{
			if(pos != null)
				pos = null;
			return;
		}
		pauseTimer--;

		update();

	}

	public void update() {


		if(pos != null)
		{
			if(canBreak(pos))
			{
				IBlockState b = mc.world.getBlockState(pos);
				if(breaking != null && breaking.blockHardness >= b.getBlock().blockHardness && hasStarted)
				{

					int lastSlot = mc.player.inventory.currentItem;

					if(!Switch.is("Off") && !breakManager)
						ItemSwitcher.Switch(new ItemForMineSwitchItem(b), ItemSwitcher.switchType.Mainhand,false);


					progress ++;


					boolean sentStopDestroyPackets = false;


					if(!hasSwitched || lastSlot == mc.player.inventory.currentItem)
					{
						if(pauseTimer <= 0 && progress > 1f/b.getPlayerRelativeBlockHardness(this.mc.player, this.mc.player.world, pos))
						{
							if(Switch.is("FastSwap"))
								Spark.switchManager.setDoSwitchToSlot(mc.playerController.currentPlayerItem);

							sentStopDestroyPackets = true;
							hasSwitched = true;
							mc.playerController.syncCurrentPlayItem();
							mc.player.connection.sendPacket(new CPacketPlayerDigging(
									CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, pos, facing
							));





							pauseTimer = delay.getValue();
						}
					}



					if(Switch.is("Silent") || !sentStopDestroyPackets)
					{
						mc.player.inventory.currentItem = lastSlot;
						mc.playerController.syncCurrentPlayItem();
					}




				}
				else{
					mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, pos, facing));
					mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, pos, facing));
					hasStarted = true;
					breaking = b.getBlock();
					progress = 0;
				}
			}
			else{

				if(!instant.isOn() && !Spark.breakManager.doInstaMine())
					pos = null;

				if(instaSwitch.isOn())
					hasSwitched = false;
			}




		}
	}




	@SubscribeEvent
	public void onPacket(PacketSendEvent event) {


		if (event.getPacket() instanceof CPacketPlayerDigging)
		{
			CPacketPlayerDigging digging = event.getPacket();
			if(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK == digging.getAction())
			{
				if(pos != null)
					event.setCanceled(true);
			}
		}
	}

	@SubscribeEvent
	public void onRender(RenderWorldLastEvent event) {
		if(pos != null) {
			AxisAlignedBB b = mc.world.getBlockState(pos).getSelectedBoundingBox(mc.world, pos);
			IBlockState a = mc.world.getBlockState(pos);
			int lastSlot = mc.player.inventory.currentItem;
			ItemSwitcher.Switch(new ItemForMineSwitchItem(a), ItemSwitcher.switchType.Mainhand,false);
			double f = Math.min(progress*a.getPlayerRelativeBlockHardness(mc.player, mc.world, pos), 1);
			mc.player.inventory.currentItem = lastSlot;
			double add = (b.maxY - b.minY) * f;
			b = new AxisAlignedBB(b.minX, b.minY, b.minZ, b.maxX, b.minY + add, b.maxZ);
			EspUtil.boundingESPBox(b,new Color(157, 146, 146, 171), 2.0f);
		}
	}


	private boolean canBreak(BlockPos pos) {
		final IBlockState blockState = mc.world.getBlockState(pos);
		final Block block = blockState.getBlock();

		if(block == Blocks.AIR)
			return false;

		return block.getBlockHardness(blockState, mc.world, pos) != -1;
	}




}
