package me.wallhacks.spark.systems.module.modules.exploit;

import me.wallhacks.spark.Spark;
import me.wallhacks.spark.event.player.PacketReceiveEvent;
import me.wallhacks.spark.event.player.PacketSendEvent;
import me.wallhacks.spark.event.player.PlayerDamageBlockEvent;
import me.wallhacks.spark.event.player.PlayerLivingTickEvent;
import me.wallhacks.spark.systems.module.Module;
import me.wallhacks.spark.systems.setting.settings.BooleanSetting;
import me.wallhacks.spark.systems.setting.settings.ColorSetting;
import me.wallhacks.spark.systems.setting.settings.IntSetting;
import me.wallhacks.spark.systems.setting.settings.ModeSetting;
import me.wallhacks.spark.util.MC;
import me.wallhacks.spark.util.player.itemswitcher.ItemSwitcher;
import me.wallhacks.spark.util.player.itemswitcher.itemswitchers.ItemForMineSwitchItem;
import me.wallhacks.spark.util.render.ColorUtil;
import me.wallhacks.spark.util.render.EspUtil;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.init.Blocks;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.network.play.client.CPacketPlayerTryUseItemOnBlock;
import net.minecraft.network.play.server.SPacketBlockChange;
import net.minecraft.network.play.server.SPacketMultiBlockChange;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraftforge.client.event.RenderWorldLastEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

import java.awt.*;
import java.util.Arrays;

@Module.Registration(name = "PacketMine", description = "Packet mine but good!",alwaysListening = true)
public class PacketMine extends Module implements MC {

	public static PacketMine instance;
	public PacketMine() {
		instance = this;

	}

	IntSetting delay = new IntSetting("PacketDelay", this, 4, 0, 20);
	BooleanSetting instant = new BooleanSetting("Instant", this, false);

	ModeSetting Switch = new ModeSetting("Switch", this, "Normal", Arrays.asList("Normal","FastSwap","Off","Silent"));
	BooleanSetting instaSwitch = new BooleanSetting("SwitchForInstant", this, false,aBoolean -> (!Switch.is("Off") && instant.isOn()));


	IntSetting breakTries = new IntSetting("BreakTries", this, 4,0,8);

	BooleanSetting disableOnFlag = new BooleanSetting("DisableOnFlag", this, false);




	BooleanSetting render = new BooleanSetting("Render", this, true, "Render");


	ColorSetting color = new ColorSetting("Color", this, new Color(0x3843DCC8, true), "Render");
	ColorSetting doneColor = new ColorSetting("DoneColor", this, new Color(0x3843DC5C, true), "Render");

	BooleanSetting fill = new BooleanSetting("Fill", this, true, "Render");




	public boolean hasStarted = false;
	public BlockPos pos;
	EnumFacing facing;

	public double getProgress() {
		if(pos == null)
			return 0;
		IBlockState a = mc.world.getBlockState(pos);
		int lastSlot = mc.player.inventory.currentItem;
		boolean onG = mc.player.onGround;
		ItemSwitcher.Switch(new ItemForMineSwitchItem(a), ItemSwitcher.switchType.Mainhand,false);

		mc.player.onGround = true;
		double f = Math.min(progress*a.getPlayerRelativeBlockHardness(mc.player, mc.world, pos), 1);

		//reset to defaults
		mc.player.onGround = onG;
		mc.player.inventory.currentItem = lastSlot;
		return f;
	}
	public int ticksFromDone() {
		if(pos == null)
			return Integer.MAX_VALUE;
		IBlockState a = mc.world.getBlockState(pos);
		int lastSlot = mc.player.inventory.currentItem;
		boolean onG = mc.player.onGround;
		ItemSwitcher.Switch(new ItemForMineSwitchItem(a), ItemSwitcher.switchType.Mainhand,false);

		mc.player.onGround = true;
		int f = Math.max(0,(int)(1/a.getPlayerRelativeBlockHardness(mc.player, mc.world, pos))-progress);

		//reset to defaults
		mc.player.onGround = onG;
		mc.player.inventory.currentItem = lastSlot;
		return f;
	}

	int progress = 0;

	int pauseTimer = 0;


	boolean isDown = false;



	@SubscribeEvent
	public void onBreak(PlayerDamageBlockEvent.Pre event){

		if(!isEnabled() && !Spark.breakManager.doInstaMine())
			return;
		if (!canBreak(event.getPos()))
			return;

		event.setReturnValue(false);
		event.setCanceled(true);

		//thing for only firing on click down
		if(isDown)
			return;
		isDown = true;

		//toggle thing
		if(event.getPos().equals(pos)){
			if(!breakManager)
				pos = null;
			return;
		}


		progress = 0;
		hasStarted = false;
		hasSwitched = false;

		breakManager = Spark.breakManager.block != null;

		pos = event.getPos();
		facing = event.getFacing();
	}

	public boolean hasSwitched = false;

	boolean breakManager = false;

	Block breaking;

	@SubscribeEvent
	public void onUpdate(PlayerLivingTickEvent event) {



		if(!isEnabled() && !Spark.breakManager.doInstaMine())
		{
			if(pos != null)
				pos = null;
			return;
		}

		if(isDown && !mc.gameSettings.keyBindAttack.isKeyDown())
			isDown = false;


		pauseTimer--;

		update();

	}

	boolean shouldBeGone = false;
	int flags = 0;

	AxisAlignedBB lastBB;

	public void update() {


		if(pos != null)
		{
			if(canBreak(pos))
			{
				lastBB = mc.world.getBlockState(pos).getSelectedBoundingBox(mc.world, pos);

				IBlockState b = mc.world.getBlockState(pos);
				if(breaking != null && breaking.blockHardness >= b.getBlock().blockHardness && hasStarted)
				{

					int lastSlot = mc.player.inventory.currentItem;

					if(!Switch.is("Off") && !breakManager)
						ItemSwitcher.Switch(new ItemForMineSwitchItem(b), ItemSwitcher.switchType.Mainhand,false);


					progress ++;


					boolean sentStopDestroyPackets = false;



					if(!hasSwitched || lastSlot == mc.player.inventory.currentItem)
					{
						if(pauseTimer <= 0 && progress > 1f/b.getPlayerRelativeBlockHardness(this.mc.player, this.mc.player.world, pos))
						{
							if(Switch.is("FastSwap"))
								Spark.switchManager.setDoSwitchToSlot(mc.playerController.currentPlayerItem);

							sentStopDestroyPackets = true;
							hasSwitched = true;
							mc.playerController.syncCurrentPlayItem();
							mc.player.connection.sendPacket(new CPacketPlayerDigging(
									CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, pos, facing
							));

							shouldBeGone = true;

							pauseTimer = delay.getValue();
						}
					}



					if(Switch.is("Silent") || !sentStopDestroyPackets)
					{
						mc.player.inventory.currentItem = lastSlot;
						mc.playerController.syncCurrentPlayItem();
					}




				}
				else{
					mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, pos, facing));
					mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, pos, facing));
					hasStarted = true;
					hasSwitched = false;
					shouldBeGone = false;
					flags = 0;
					breaking = b.getBlock();
					progress = 0;


				}
			}
			else{

				if(!instant.isOn() && !Spark.breakManager.doInstaMine())
					pos = null;

				if(instaSwitch.isOn())
					hasSwitched = false;
				shouldBeGone = false;
				flags = 0;
			}




		}
	}


	//saves last pos placed on
	BlockPos placed = null;

	@SubscribeEvent
	public void onPacketSend(PacketSendEvent event) {

		if (event.getPacket() instanceof CPacketPlayerTryUseItemOnBlock)
		{
			CPacketPlayerTryUseItemOnBlock place = event.getPacket();
			placed = place.getPos().add(place.getDirection().getDirectionVec());
		}
		if (event.getPacket() instanceof CPacketPlayerDigging)
		{
			CPacketPlayerDigging digging = event.getPacket();
			if(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK == digging.getAction())
			{
				if(pos != null)
					event.setCanceled(true);
			}
		}

	}

	@SubscribeEvent
	public void onPacketGet(PacketReceiveEvent event) {
		if (event.getPacket() instanceof SPacketMultiBlockChange) {
			for (SPacketMultiBlockChange.BlockUpdateData pos : ((SPacketMultiBlockChange) event.getPacket()).getChangedBlocks()) {

				blockChanged(pos.getPos(),pos.getBlockState());
			}
		} else if (event.getPacket() instanceof SPacketBlockChange) {
			blockChanged(((SPacketBlockChange) event.getPacket()).getBlockPosition(),((SPacketBlockChange) event.getPacket()).blockState);
		}
	}
	protected void blockChanged(BlockPos p,IBlockState state) {
		if(!isEnabled() && !Spark.breakManager.doInstaMine())
			return;

		//we need this
		if(p.equals(placed))
		{
			placed = null;
			return;
		}

		if(pos != null && shouldBeGone)
		{
			if(pos.equals(p))
			{
				if(state.getBlock() != Blocks.AIR)
				{
					//we did it - block was mined
					shouldBeGone = false;
				}
				else
				{
					flags++;
					if(flags > breakTries.getValue())
					{
						Spark.sendInfo("Insta mine failed! Failed break attempts: "+flags);
						//flag
						if(disableOnFlag.isOn())
							pos = null;
						hasStarted = false;
						shouldBeGone = false;
					}

				}
			}
		}
	}



	private boolean canBreak(BlockPos pos) {
		final IBlockState blockState = mc.world.getBlockState(pos);
		final Block block = blockState.getBlock();

		if(block == Blocks.AIR)
			return false;

		float f = block.getBlockHardness(blockState, mc.world, pos);
		return f != -1 & f > 0.1;
	}




	@SubscribeEvent
	public void onRender(RenderWorldLastEvent event) {
		if(!isEnabled() && !Spark.breakManager.doInstaMine())
			return;

		if(pos != null && render.isOn()) {
			AxisAlignedBB b = lastBB != null ? lastBB : mc.world.getBlockState(pos).getSelectedBoundingBox(mc.world, pos);
			IBlockState a = mc.world.getBlockState(pos);


			double f = getProgress();


			b = new AxisAlignedBB(b.minX, b.minY, b.minZ, b.maxX, b.minY + (b.maxY - b.minY) * f, b.maxZ);

			Color c = ColorUtil.lerpColor(color.getColor(),doneColor.getColor(),(float) f);

			EspUtil.boundingESPBox(b,c.brighter(), 2.0f);
			if(fill.isOn() && canBreak(pos))
				EspUtil.boundingESPBoxFilled(b,c);
		}
	}




}
