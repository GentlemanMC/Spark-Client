package me.wallhacks.spark.systems.module.modules.exploit;

import java.awt.Color;

import me.wallhacks.spark.event.player.PacketReceiveEvent;
import me.wallhacks.spark.event.player.PacketSendEvent;
import me.wallhacks.spark.event.player.PlayerUpdateEvent;
import me.wallhacks.spark.systems.module.Module;
import me.wallhacks.spark.systems.setting.settings.ColorSetting;
import me.wallhacks.spark.util.render.ColorUtil;
import me.wallhacks.spark.util.render.EspUtil;
import net.minecraft.init.Items;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.network.play.server.SPacketPlayerPosLook;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.Vec3d;
import net.minecraftforge.client.event.RenderWorldLastEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.network.FMLNetworkEvent.ClientDisconnectionFromServerEvent;

@Module.Registration(name = "ChorusControl", description = "Makes you able to hold chorus teleportation or cancel it")
public class ChorusControl extends Module {

	ColorSetting currentposition = new ColorSetting("CurrentPosition", this, Color.RED);
	ColorSetting highlight = new ColorSetting("Highlight", this, Color.CYAN);
	
	Vec3d choruspos = null;
	Vec3d currentpos = null;
	SPacketPlayerPosLook chorusPacket = null;
	boolean isEatingChorus = false;
	int chorusTicks = 0;
	
	@Override
	public void disable() {
		super.disable();
		if(chorusPacket != null) {
			chorusPacket.processPacket(mc.getConnection());
			reset();
		}
	}
	
	private void reset() {
		chorusPacket = null;
		choruspos = null;
		currentpos = null;
	}
	
	@SubscribeEvent
	public void onDisconnect(ClientDisconnectionFromServerEvent e) {
		super.disable();
		reset();
	}
	
	@SubscribeEvent
	public void onRenderLast(RenderWorldLastEvent e) {
		if(choruspos != null) {
			AxisAlignedBB aabb = new AxisAlignedBB(choruspos.add(-0.25, 0, -0.25), choruspos.add(0.25, 2, 0.25));
			EspUtil.boundingESPBoxFilled(aabb, ColorUtil.mutiplyAlpha(highlight.getColor(),0.5f));
			EspUtil.boundingESPBox(aabb, highlight.getColor(), 1);
		}
		if(currentpos != null) {
			AxisAlignedBB aabb = new AxisAlignedBB(currentpos.add(-0.1, 0, -0.1), currentpos.add(0.1, 2, 0.1));
			EspUtil.boundingESPBoxFilled(aabb, ColorUtil.mutiplyAlpha(currentposition.getColor(),0.5f));
		}
	}
	
	@SubscribeEvent
	public void onUpdate(PlayerUpdateEvent e) {
		if(mc.player.getActiveItemStack().getItem() == Items.CHORUS_FRUIT) {
			isEatingChorus = true;
		} else if(isEatingChorus){
			chorusTicks++;
			if(chorusTicks > 5) {
				isEatingChorus = false;
				chorusTicks = 0;
			}
		}
		if(mc.player.isSneaking()) {
			if(chorusPacket != null) {
				chorusPacket.processPacket(mc.getConnection());
				reset();
			}
		}
	}
	
	@SubscribeEvent
	public void onPacketIn(PacketReceiveEvent e) {
		if(e.getPacket() instanceof SPacketPlayerPosLook) {
			if(isEatingChorus || choruspos != null) {
				chorusPacket = e.getPacket();
				choruspos = new Vec3d(chorusPacket.x, chorusPacket.y, chorusPacket.z);
				if(currentpos == null) currentpos = mc.player.getPositionVector();
				e.setCanceled(true);
			}
		}
	}
	
	@SubscribeEvent
	public void onPacketOut(PacketSendEvent e) {
		if(chorusPacket != null && e.getPacket() instanceof CPacketPlayer) {
			e.setCanceled(true);
		}
	}
}
